<script type="text/x-red" data-template-name="Firestore in">
<div class="firestore">
    <div class="form-row">
      <label for="node-input-admin"><i class="fa fa-cogs"></i> Admin </label>
      <input type="text" id="node-input-admin">
    </div>
    <div class="form-row">
      <label for="node-input-name"><i class="fa fa-tag"></i> Node Name </label>
      <input type="text" id="node-input-name">
    </div>
    <div class="form-row">
      <label for="node-input-collection"><i class="fa fa-archive"></i> Collection </label>
      <input type="text" id="node-input-collection">
    </div>
    <div class="form-row">
      <label for="node-input-document"><i class="fa fa-file"></i> Document </label>
      <input type="text" id="node-input-document" placeholder="doc name">
    </div>
    <div class="form-row">
      <label for="node-input-realtime"><i class="fa fa-bolt"></i> Realtime </label>
      <input type="checkbox" id="node-input-realtime">
    </div>
    <div class="form-row">
      <label for="node-input-group"><i class="fa fa-sort"></i> Group</label>
      <input type="checkbox" id="node-input-group">
    </div>
    <div class="form-row">
        <label><i class="fa fa-search"></i> Query</label>
    </div>
    <div class="node-input-query-container-row">
        <ol id="node-input-query-container"></ol>
    </div>
    <hr/>
    <div class="collapsible">
      <div class="form-row-header">Expert zone</div>
      <div>
        <div class="form-row" style="margin-bottom: 0px;">
          <label for="node-input-snapHandler" class="long"><i class="fa fa-wrench"></i> Snap handler</label>
          <input type="hidden" id="node-input-snapHandler"/>
          <input type="hidden" id="node-input-noerr">
        </div>
        <div class="form-row node-text-editor-row" style="position:relative">
          <div style="position: absolute; right:0; bottom:calc(100% + 3px);"><button id="node-function-expand-js" class="red-ui-button red-ui-button-small"><i class="fa fa-expand"></i></button></div>
          <div style="height: 250px; min-height:150px;" class="node-text-editor" id="node-input-func-editor" ></div>
        </div>
      <div>
    </div>
  </div>
</script>

<script type="text/x-red" data-help-name="Firestore in">
    <p>The node fetches data from a referenced collection or referenced document</p>
    <h3>Inputs</h3>
    <p>Received on the <code>msg.firestore</code> property</p>
    <dl class="message-properties">
        <dt>
          collection <span class="property-type">string</span>
        </dt>
        <dd>The collection reference point</dd>
        <dt class="optional">
          document <span class="property-type">string</span>
        </dt>
        <dd>The document reference to the set collection</dd>
        <dt class="optional">
          realtime <span class="property-type">boolean</span>
          </dt>
        <dd>If set, the node emits live data changes on the watched reference</dd>
        <dt class="optional">
          group <span class="property-type">boolean</span>
          </dt>
        <dd>If set, the query will be run against a collection group (may require indexing)
        <dt class="optional">
          query <span class="property-type">array&lt;object&gt;</span>
          </dt>
        <dd>an array of objects defining query methods to apply to the read</dd>
        <dt class="optional">
          disableHandler <span class="property-type">boolean</span>
          </dt>
        <dd>disables the default snapshot handler, exposing a built query reference as the payload</dd>
    </dl>
    <p>
      The above inputs can also be set from within the
      node itself but can be overridden by corresponding message properties.
    <br>
    Sample <code>msg.firestore</code><br>
    <pre>msg.firestore = {
     collection: 'farm',
     document: 'cows',
     realtime: true,
     group: false,
     query: [{where: ["name", "==", "milky"]}]
    }</pre>
    </p>
    <h3>Outputs</h3>
    Response data from the operation is output through the <code>msg.payload</code> property
    <h3>Expert Zone</h3>
    <p>In the expert zone, you can edit the default snap handle.</p>
    <p>You'll have access to a <code>snap</code> object containing the query snapshot. What you <code>return</code> will then be send in the output payload.</p>
    <pre>
const docs = [];
snap.docChanges().forEach(change => {
  docs.push(change.doc.data());
  if (change.type === 'added') {
    console.log('Added: ', change.doc.data());
  }
  if (change.type === 'modified') {
    console.log('Modified: ', change.doc.data());
  }
  if (change.type === 'removed') {
    console.log('Removed: ', change.doc.data());
  }
});
return docs;
    </pre>
</script>

<style type="text/css">
  .firestore .node-input-query-container-row {
    width: 100%;
  }

  #node-input-query-container .input-query-row {
    display: grid;
    grid-gap: 10px;
    grid-template-columns: 1fr 3fr;
    margin-top: 8px;
  }

  .input-query-row .input-query-label {
    text-align: right;
  }

  .input-query-row input, .input-query-row select {
    width: 100%;
  }

  label[for="node-input-snapHandler"].long {
    width: 150px;
  }
</style>

<script type="text/javascript">
  RED.nodes.registerType('Firestore in', {
    category: 'firebase',
    defaults: {
      name: {required: false},
      collection: {value: '', required: true},
      group: {value: false},
      document: {value: ''},
      realtime: {value: false},
      query: {value: []},
      admin: {type: "firebase admin", required: true},
      snapHandler: {required: false}
    },
    color: "#F3B567",
    inputs: 1,
    outputs: 1,
    icon: "file.png",
    align: "left",
    label: function () {
      return this.name || this.collection || "Firestore Read";
    },
    labelStyle: function () {
      return (this.collection && !this.name) ? "node_label_italic" : "";
    },
    oneditprepare: function () {
      const listContainer = $('#node-input-query-container')

      listContainer
          .css('min-height', '250px')
          .css('min-width', '300px')
          .editableList({
            header: $("<div>").append($.parseHTML("<div style='width:28%; display: inline-grid'>Method</div><div style='display: inline-grid'>Arguments</div>")),
            addItem(container, i, data) {
              container.css({
                overflow: 'hidden',
                whiteSpace: 'nowrap'
              });

              // query option item
              let baseRow = $('<div/>', {class: 'input-query-row'}).appendTo(container);

              let methodSelect = $('<select/>', {
                class: "node-input-query-method-type",
                style: "margin-top:0;"
              }).appendTo(baseRow);

              let methodOptions = ["where", "orderBy", "startAt", "endAt", "startAfter", "endBefore", "offset", "limit"]

              for (let x = 0; x < methodOptions.length; x++) {
                methodSelect.append($("<option></option>").val(methodOptions[x]).text(methodOptions[x]));
              }

              // query field argument in text format
              let textArgument = $('<input/>', {
                class: "node-input-query-text-field",
                required: "required",
                type: "text"
              }).appendTo(baseRow)

              // query field argument in numerical format
              let numberArgument = $('<input/>', {
                class: "node-input-query-number-field",
                required: "required",
                type: "number"
              }).appendTo(baseRow)

              // direction string drop down option
              let directionStrRow = $('<div/>', {class: 'input-query-row'}).appendTo(container);

              $('<div/>', {class: 'input-query-label'}).text("direction").appendTo(directionStrRow);

              let directionSelect = $('<select/>', {class: "node-input-query-direction-select", type: "text"})
                  .appendTo(directionStrRow)

              let directionSelectOptions = [{v: null, l: 'none'}, {v: 'asc', l: 'ascending'}, {
                v: 'desc',
                l: 'descending'
              }]

              for (let x = 0; x < directionSelectOptions.length; x++) {
                directionSelect.append($("<option></option>").val(directionSelectOptions[x].v).text(directionSelectOptions[x].l));
              }

              // operation dropdown option
              let operationOptRow = $('<div/>', {class: 'input-query-row'}).appendTo(container);

              $('<div/>', {class: 'input-query-label'}).text("operation").appendTo(operationOptRow);

              let operationSelect = $('<select/>', {
                class: "node-input-query-operation-string"
              }).appendTo(operationOptRow)

              let operationOptions = ["<", "<=", "==", ">", ">=", "array-contains"]

              for (let x = 0; x < operationOptions.length; x++) {
                operationSelect.append($("<option></option>").val(operationOptions[x]).text(operationOptions[x]));
              }

              // value field option
              let valueFieldRow = $('<div/>', {class: 'input-query-row'}).appendTo(container);

              $('<div/>', {class: 'input-query-label'}).text("value").appendTo(valueFieldRow);

              let valueFieldInput = $('<input/>', {
                class: "node-input-query-value-field",
                required: "required",
                type: "text",
                placeholder: "value"
              }).appendTo(valueFieldRow)

              methodSelect.change(function () {
                let type = $(this).val()
                switch (type) {
                  case 'where':
                    textArgument.show()
                    valueFieldRow.show()
                    operationOptRow.show()
                    numberArgument.hide()
                    directionStrRow.hide()
                    break;
                  case 'orderBy':
                    textArgument.show()
                    directionStrRow.show()
                    numberArgument.hide()
                    operationOptRow.hide()
                    valueFieldRow.hide()
                    break;
                  case 'startAt':
                  case 'endAt':
                  case 'startAfter':
                  case 'endBefore':
                    textArgument.show()
                    numberArgument.hide()
                    directionStrRow.hide()
                    operationOptRow.hide()
                    valueFieldRow.hide()
                    break;
                  case 'offset':
                  case 'limit':
                    numberArgument.show()
                    textArgument.hide()
                    directionStrRow.hide()
                    operationOptRow.hide()
                    valueFieldRow.hide()
                    break;
                }
              });

              const dataKeys = Object.keys(data)
              if (dataKeys.length > 0) {
                const method = dataKeys[0]
                const value = data[method]

                methodSelect.val(method)

                switch (method) {
                  case 'where':
                    textArgument.val(value.field)
                    operationSelect.val(value.operation)
                    valueFieldInput.val(value.value)
                    break;
                  case 'orderBy':
                    textArgument.val(value.field)
                    directionSelect.val(value.direction)
                    break;
                  case 'startAt':
                  case 'endAt':
                  case 'startAfter':
                  case 'endBefore':
                    textArgument.val(value)
                    break;
                  case 'limit':
                  case 'offset':
                    numberArgument.val(value)
                    break;
                }

                methodSelect.change()
                textArgument.change()
                numberArgument.change()
                directionSelect.change()
                operationSelect.change()
              } else {
                // Default method
                methodSelect.val("orderBy").change()
              }
            },
            removable: true,
            sortable: true
          })

      if (!this.query) this.query = []

      for (var i = 0; i < this.query.length; i++) {
        var query = this.query[i];
        listContainer.editableList('addItem', query);
      }

      // Snap Handler editor
      var that = this;
      this.editor = RED.editor.createEditor({
          id: 'node-input-func-editor',
          mode: 'ace/mode/nrjavascript',
          value: $("#node-input-snapHandler").val(),
          globals: {
              msg:true,
              context:true,
              RED: true,
              util: true,
              flow: true,
              global: true,
              console: true,
              Buffer: true,
              setTimeout: true,
              clearTimeout: true,
              setInterval: true,
              clearInterval: true
          }
      });

      RED.library.create({
          url:"functions", // where to get the data from
          type:"function", // the type of object the library is for
          editor:this.editor, // the field name the main text body goes to
          mode:"ace/mode/nrjavascript",
          fields:['name','outputs'],
          ext:"js"
      });
      this.editor.focus();

      RED.popover.tooltip($("#node-function-expand-js"), RED._("node-red:common.label.expand"));

      $("#node-function-expand-js").on("click", function(e) {
          e.preventDefault();
          var value = that.editor.getValue();
          RED.editor.editJavaScript({
              value: value,
              width: "Infinity",
              cursor: that.editor.getCursorPosition(),
              mode: "ace/mode/nrjavascript",
              complete: function(v,cursor) {
                  that.editor.setValue(v, -1);
                  that.editor.gotoLine(cursor.row+1,cursor.column,false);
                  setTimeout(function() {
                      that.editor.focus();
                  },300);
              }
          })
      })
      // Expert zone accordion
      $('.collapsible').accordion({
        collapsible: true,
        active: $("#node-input-snapHandler").val() ? 0 : false
      });
    },
    oneditsave: function () {
      const queryItems = $("#node-input-query-container").editableList("items")
      const node = this

      node.query = []

      queryItems.each(function () {
        const queries = $(this)
        const method = queries.find(".node-input-query-method-type").val()

        let q = {}

        const textFieldArgument = queries.find(".node-input-query-text-field").val()
        const numberFieldArgument = queries.find(".node-input-query-number-field").val()
        const value = queries.find(".node-input-query-value-field").val()

        switch (method) {
          case 'where':
            const operation = queries.find(".node-input-query-operation-string").val()
            q.where = {field: textFieldArgument, operation, value}
            break;
          case 'orderBy':
            const direction = queries.find(".node-input-query-direction-select").val()
            q.orderBy = {field: textFieldArgument, direction}
            break;
          case 'startAt':
          case 'endAt':
          case 'startAfter':
          case 'endBefore':
            let valueArray = textFieldArgument.split(',').map((item) => item.trim())
            q[method] = valueArray.length === 1 ? valueArray[0] : valueArray
            break;
          case 'limit':
          case 'offset':
            q[method] = parseInt(numberFieldArgument)
            break;
        }

        node.query.push(q)
      })

      // Snap handler editor
      var annot = this.editor.getSession().getAnnotations();
      this.noerr = 0;
      $("#node-input-noerr").val(0);
      for (var k=0; k < annot.length; k++) {
          if (annot[k].type === "error") {
              $("#node-input-noerr").val(annot.length);
              this.noerr = annot.length;
          }
      }
      $("#node-input-snapHandler").val(this.editor.getValue());
      this.editor.destroy();
      delete this.editor;
    },
    oneditcancel: function() {
      this.editor.destroy();
      delete this.editor;
    },
    oneditresize: function(size) {
      var rows = $("#dialog-form>div:not(.node-text-editor-row)");
      var height = $("#dialog-form").height();
      for (var i=0; i<rows.length; i++) {
        height -= $(rows[i]).outerHeight(true);
      }
      var editorRow = $("#dialog-form>div.node-text-editor-row");
      height -= (parseInt(editorRow.css("marginTop"))+parseInt(editorRow.css("marginBottom")));
      $(".node-text-editor").css("height",height+"px");
      this.editor.resize();
    }
  });
</script>

